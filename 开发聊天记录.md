# ScreenMailer 开发聊天记录

## 项目概述

ScreenMailer 是一个用于 Windows 虚拟机监控的自动化工具，通过定时截屏和邮件发送功能实现远程监控。配有图形用户界面，支持生成独立可执行文件。

## 开发过程记录

### 初始开发阶段

1. **项目结构设计**

    - 设计了模块化的项目结构，包括截图、邮件、调度器等功能模块
    - 确定了配置文件格式和数据存储方案

2. **核心功能模块实现**

    - 实现了基于 PIL 的截图功能，支持全屏和区域截图
    - 开发了基于 SMTP 的邮件发送模块
    - 实现了基于 schedule 库的定时任务调度系统

3. **GUI 界面开发**
    - 使用 PyQt5 设计了多标签页的图形用户界面
    - 实现了配置的可视化编辑和保存
    - 添加了仪表盘显示运行状态

### 打包和构建阶段

1. **打包脚本开发**

    - 创建了 build_exe.py 用于自动打包应用
    - 使用 PyInstaller 将项目打包为单个可执行文件

2. **图标设计**

    - 开发了 create_icon.py 脚本生成高分辨率应用图标
    - 创建了 1024x1024 分辨率的图标，带有相机和邮件的视觉元素

3. **打包问题修复**
    - 解决了 PIL 模块导入问题
    - 修复了 smtplib 等标准库的依赖问题
    - 修复了各种资源引用路径问题

### 改进和优化阶段

1. **数据存储目录调整**

    - 从 AppData/Local 目录迁移到用户的"文档"文件夹
    - 使用 Windows API 确保跨系统兼容性

2. **功能优化**

    - 添加了多收件人支持
    - 改进了调度器的时间设置，支持多种发送模式
    - 增强了图标设计，提高分辨率到 1024x1024

3. **错误修复**
    - 修复了 QInputDialog 未导入导致的闪退问题
    - 修复了 QSpinBox 设置浮点值的类型错误
    - 处理了资源引用和依赖库的路径问题

## 关键技术笔记

### 截图实现

```python
# 使用PIL库的ImageGrab模块实现截图功能
import PIL.ImageGrab

def capture_screenshot(bbox=None, format='png', quality=90):
    """
    捕获屏幕截图
    bbox: 截图区域，格式为(left, top, right, bottom)，为None时截取全屏
    format: 图片格式，如'png'或'jpg'
    quality: 图片质量，1-100
    """
    # 截取屏幕
    screenshot = PIL.ImageGrab.grab(bbox=bbox)

    # 保存图片
    filepath = f"screenshot_{time.strftime('%Y%m%d%H%M%S')}.{format}"
    screenshot.save(filepath, format=format, quality=quality)
    return filepath
```

### 邮件发送

```python
# SMTP邮件发送示例
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.image import MIMEImage

def send_email(smtp_server, port, username, password, sender, recipients,
               subject, message, image_paths=None, use_ssl=False):
    """发送带有图片附件的邮件"""
    # 创建邮件对象
    msg = MIMEMultipart()
    msg['From'] = sender
    msg['To'] = ", ".join(recipients)
    msg['Subject'] = subject

    # 添加正文
    msg.attach(MIMEText(message, 'plain'))

    # 添加图片附件
    if image_paths:
        for img_path in image_paths:
            with open(img_path, 'rb') as f:
                img = MIMEImage(f.read())
                img.add_header('Content-Disposition', 'attachment', filename=os.path.basename(img_path))
                msg.attach(img)

    # 发送邮件
    try:
        if use_ssl:
            server = smtplib.SMTP_SSL(smtp_server, port)
        else:
            server = smtplib.SMTP(smtp_server, port)
            server.starttls()  # 启用TLS加密

        server.login(username, password)
        server.send_message(msg)
        server.quit()
        return True
    except Exception as e:
        print(f"邮件发送失败: {e}")
        return False
```

### 调度器实现

```python
# 使用schedule库实现定时任务
import schedule
import time
import threading

class Scheduler:
    def __init__(self, screen_capture, email_sender, config):
        self.screen_capture = screen_capture
        self.email_sender = email_sender
        self.config = config
        self.running = False
        self.thread = None

    def start(self):
        """启动调度器"""
        if self.running:
            return

        self.running = True
        self.setup_jobs()

        # 在单独的线程中运行调度器
        self.thread = threading.Thread(target=self._run_scheduler)
        self.thread.daemon = True
        self.thread.start()

    def stop(self):
        """停止调度器"""
        self.running = False
        schedule.clear()

    def _run_scheduler(self):
        """运行调度器线程"""
        while self.running:
            schedule.run_pending()
            time.sleep(1)

    def setup_jobs(self):
        """设置定时任务"""
        # 清除现有任务
        schedule.clear()

        # 设置截图任务
        interval = self.config.get('screenshot_interval', 300)
        schedule.every(interval).seconds.do(self.capture_task)

        # 设置邮件发送任务
        email_mode = self.config.get('email_mode', 'interval')
        if email_mode == 'interval':
            email_interval = self.config.get('email_interval', 3600)
            schedule.every(email_interval).seconds.do(self.email_task)
        elif email_mode == 'hourly':
            schedule.every().hour.at(":00").do(self.email_task)
        elif email_mode == 'half_hourly':
            schedule.every().hour.at(":00").do(self.email_task)
            schedule.every().hour.at(":30").do(self.email_task)
        elif email_mode == 'custom':
            custom_times = self.config.get('email_custom_times', [])
            for time_str in custom_times:
                schedule.every().day.at(time_str).do(self.email_task)
```

### GUI 界面实现

```python
# 使用PyQt5创建图形界面
from PyQt5.QtWidgets import QApplication, QMainWindow, QWidget, QVBoxLayout, QTabWidget

class ScreenMailerGUI(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("ScreenMailer")
        self.setGeometry(100, 100, 800, 600)

        # 创建中央部件和标签页
        central_widget = QWidget()
        self.setCentralWidget(central_widget)

        main_layout = QVBoxLayout(central_widget)
        self.tabs = QTabWidget()
        main_layout.addWidget(self.tabs)

        # 添加各功能标签页
        self.create_dashboard_tab()
        self.create_email_config_tab()
        self.create_screenshot_config_tab()
        self.create_scheduler_config_tab()
        self.create_logs_tab()
```

### 打包脚本

```python
# 使用PyInstaller打包为可执行文件
import PyInstaller.__main__

def build_exe():
    """构建可执行文件"""
    pyinstaller_args = [
        'screenmailer_gui.py',      # 主程序文件
        '--name=ScreenMailer',      # 生成的可执行文件名称
        '--onefile',                # 打包成单个可执行文件
        '--windowed',               # 使用Windows子系统，不显示控制台窗口
        '--icon=icon.ico',          # 应用程序图标
        '--hidden-import=PIL',      # 添加隐式导入
        '--hidden-import=smtplib',
        '--hidden-import=email',
        # ...其他依赖库
    ]

    # 调用PyInstaller
    PyInstaller.__main__.run(pyinstaller_args)
```

## 遇到的问题和解决方案

### 1. 打包时模块导入问题

**问题**: PyInstaller 打包后运行时出现"No module named 'PIL'"和"No module named 'smtplib'"错误。

**解决方案**:

-   在打包脚本中显式添加隐式导入:
    ```python
    '--hidden-import=PIL',
    '--hidden-import=PIL._imagingtk',
    '--hidden-import=smtplib',
    '--hidden-import=email',
    ```

### 2. GUI 中 QSpinBox 设置浮点值类型错误

**问题**: 调度器配置中尝试将配置文件中的浮点数值设置给 QSpinBox 时出现类型错误。

**解决方案**:

-   使用 int()函数将浮点数转换为整数:
    ```python
    self.screenshot_interval_spinbox.setValue(int(scheduler_config.get('screenshot_interval', 300)))
    ```

### 3. 添加收件人功能闪退问题

**问题**: 点击添加收件人按钮时程序闪退，因为缺少 QInputDialog 的导入。

**解决方案**:

-   添加缺失的导入语句:
    ```python
    from PyQt5.QtWidgets import (..., QInputDialog)
    ```

### 4. 数据存储位置问题

**问题**: 默认在 AppData\Local 中保存数据不够直观，用户难以找到。

**解决方案**:

-   修改为在用户"文档"文件夹中保存:
    ```python
    # 使用Windows API获取文档文件夹路径
    import ctypes.wintypes
    CSIDL_PERSONAL = 5  # "我的文档"文件夹的ID
    buf = ctypes.create_unicode_buffer(ctypes.wintypes.MAX_PATH)
    ctypes.windll.shell32.SHGetFolderPathW(0, CSIDL_PERSONAL, 0, 0, buf)
    documents_path = buf.value
    self.app_data_dir = os.path.join(documents_path, app_name)
    ```

## 未来改进计划

1. **异常检测功能**

    - 添加图像分析功能，检测屏幕异常变化
    - 实现基于变化率的告警机制

2. **增强的安全功能**

    - 添加邮件内容加密选项
    - 实现密码存储加密

3. **更多自定义选项**

    - 支持更多图像格式和压缩选项
    - 添加截图区域可视化选择工具

4. **远程控制功能**
    - 通过邮件命令实现远程控制计算机
    - 添加基于 Web 的远程监控界面

## 常见问题解答

1. **Q: 如何设置开机自启动?**  
   A: 可以使用 Windows 任务计划程序，设置在计算机启动时运行 ScreenMailer.exe。

2. **Q: 如何更改截图保存位置?**  
   A: 目前截图保存在用户"文档"文件夹中的 ScreenMailer/screenshots 目录下，可以在代码中修改路径设置。

3. **Q: 支持哪些邮件服务器?**  
   A: 支持任何标准 SMTP 邮件服务器，包括 Gmail、Outlook、QQ 邮箱等，需要在设置中提供正确的服务器地址和端口。

4. **Q: 如何修改截图质量?**  
   A: 在 GUI 的"截图设置"选项卡中可以调整图片格式和质量参数。

5. **Q: 程序占用多少系统资源?**  
   A: 程序设计为低资源占用，正常运行时内存占用约 50-100MB，CPU 使用率通常小于 1%。

6. **Q: 为什么打包后的程序比源代码大很多?**  
   A: 打包后的程序包含了 Python 解释器和所有依赖库，因此体积较大（约 30-40MB）。

---

最后更新: 2025 年 4 月 23 日
